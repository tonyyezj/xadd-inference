
CMDP Definition:
===============
BVars:       [] = S:[] + I:[] = XADD (all vars): []
NS BVars:    []
CVars:       [x2, k, x1] = S:[x2, k, x1] + A:[] + I:[]
NS CVars:    [k', x1', x2']
Noise vars:  []
Min-values:  {k'=1.0E-6, x1'=1.0E-6, x2'=1.0E-6, x2=1.0E-6, k=1.0E-6, x1=1.0E-6}
Max-values:  {k'=100.0, x1'=100.0, x2'=100.0, x2=100.0, k=100.0, x1=100.0}
Order:       [xadd.XADD$NullDec@0, (1 + (-0.01 * k) + (-0.01 * x1)) > 0, (1 + (-0.01 * k) + (-0.01 * x2)) > 0]
Iterations:  2
Linearity:  true
Actions (3):

==> move2 ( ):
*****
CPF: k' [x2, k]:
( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
    ( [((1 * k) + (1 * x2))] ) 
    ( [(1 * k)] ) ) 
*****
CPF: x1' [x1]:
( [(1 * x1)] )
*****
CPF: x2' [x2, k]:
( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
    ( [0] ) 
    ( [(1 * x2)] ) ) 
*****
Reward: [x2, k]:
( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
    ( [(1 * x2)] ) 
    ( [0] ) ) 
*****

==> move1 ( ):
*****
CPF: k' [k, x1]:
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [((1 * k) + (1 * x1))] ) 
    ( [(1 * k)] ) ) 
*****
CPF: x1' [k, x1]:
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [0] ) 
    ( [(1 * x1)] ) ) 
*****
CPF: x2' [x2]:
( [(1 * x2)] )
*****
Reward: [k, x1]:
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 * x1)] ) 
    ( [0] ) ) 
*****

==> noop ( ):
*****
CPF: k' [k]:
( [(1 * k)] )
*****
CPF: x1' [x1]:
( [(1 * x1)] )
*****
CPF: x2' [x2]:
( [(1 * x2)] )
*****
Reward: []:
( [0] )
*****


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ITERATION #1, 16435064:513802240 bytes, 0 ms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

>>> REGRESSING 'move2'

- Primed value function:
( [0] )
- Elimination order for regression: []
- Added in reward post-marginalization with no interm/next state vars.
- Q^1(move2, [] )
( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
    ( [(1 * x2)] ) 
    ( [0] ) ) 
- Q^1(move2 ):
 No noise parameters to max over, skipping this step.
- Q^1(move2 ):
 No action parameters to max over, skipping this step.
Running max in iter 1:( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
    ( [(1 * x2)] ) 
    ( [0] ) ) 

>>> REGRESSING 'move1'

- Primed value function:
( [0] )
- Elimination order for regression: []
- Added in reward post-marginalization with no interm/next state vars.
- Q^1(move1, [] )
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 * x1)] ) 
    ( [0] ) ) 
- Q^1(move1 ):
 No noise parameters to max over, skipping this step.
- Q^1(move1 ):
 No action parameters to max over, skipping this step.
Running max in iter 1:( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 * x1)] ) 
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 

>>> REGRESSING 'noop'

- Primed value function:
( [0] )
- Elimination order for regression: []
- Added in reward post-marginalization with no interm/next state vars.
- Q^1(noop, [] )
( [0] )
- Q^1(noop ):
 No noise parameters to max over, skipping this step.
- Q^1(noop ):
 No action parameters to max over, skipping this step.
Running max in iter 1:( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 * x1)] ) 
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
Iter complete:1( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 * x1)] ) 
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
Value function size @ end of iteration 1: 7 nodes = 5 cases in 91 ms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ITERATION #2, 37999320:513802240 bytes, 0 ms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

>>> REGRESSING 'move2'

- Primed value function:
( [(1 + (-0.01 * k') + (-0.01 * x2')) > 0]
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k') + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 * x2')] ) )  
       ( [(1 * x2')] ) )  
    ( [(1 + (-0.01 * k') + (-0.01 * x1')) > 0]
       ( [(1 * x1')] ) 
       ( [0] ) )  ) 
- Elimination order for regression: [k', x1', x2', x2, k, x1]
- Integrating out: k'/3
-->: ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  
       ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x1')) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [(1 * x1')] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  )  
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  
       ( [(1 + (-0.01 * k) + (-0.01 * x1')) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [(1 * x1')] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  )  ) 
- Integrating out: x1'/4
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x2')) > 0]
          ( [((1 * x1) + (-1 * x2')) > 0]
             ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
                ( [(1 * x1)] ) 
                ( [(1 * x2')] ) )  
             ( [(1 * x2')] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [(1 * x1)] ) 
             ( [0] ) )  )  
       ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
          ( [((1 * x1) + (-1 * x2')) > 0]
             ( [(1 * x1)] ) 
             ( [(1 * x2')] ) )  
          ( [(1 * x1)] ) )  )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x2) + (-0.01 * x2')) > 0]
          ( [((1 * x1) + (-1 * x2')) > 0]
             ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
                ( [(1 * x1)] ) 
                ( [(1 * x2')] ) )  
             ( [(1 * x2')] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [(1 * x1)] ) 
             ( [0] ) )  )  
       ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
          ( [(1 * x2')] ) 
          ( [0] ) )  )  ) 
- Integrating out: x2'/5
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x1) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [(1 * x1)] ) 
             ( [0] ) )  
          ( [0] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x1) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [(1 * x1)] ) 
             ( [0] ) )  
          ( [0] ) )  
       ( [0] ) )  ) 
- Ignoring current state or action variable x2 during elimination
- Ignoring current state or action variable k during elimination
- Ignoring current state or action variable x1 during elimination
- Added in reward post-marginalization with no interm/next state vars.
- Q^2(move2, [] )
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x1) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x2)] ) )  
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x1) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x2)] ) )  
          ( [(1 * x2)] ) )  
       ( [0] ) )  ) 
- Q^2(move2 ):
 No noise parameters to max over, skipping this step.
- Q^2(move2 ):
 No action parameters to max over, skipping this step.
Running max in iter 2:( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
          ( [((1 * x1) + (1 * x2))] ) 
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 

>>> REGRESSING 'move1'

- Primed value function:
( [(1 + (-0.01 * k') + (-0.01 * x2')) > 0]
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k') + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 * x2')] ) )  
       ( [(1 * x2')] ) )  
    ( [(1 + (-0.01 * k') + (-0.01 * x1')) > 0]
       ( [(1 * x1')] ) 
       ( [0] ) )  ) 
- Elimination order for regression: [k', x1', x2', x2, k, x1]
- Integrating out: k'/3
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  
       ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x1')) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [(1 * x1')] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  )  
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  
       ( [(1 + (-0.01 * k) + (-0.01 * x1')) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [(1 * x1')] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
             ( [(1 * x2')] ) 
             ( [0] ) )  )  )  ) 
- Integrating out: x1'/4
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2')) > 0]
       ( [(-1 * x2') > 0]
          ( [0] ) 
          ( [(1 * x2')] ) )  
       ( [0] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
       ( [(1 * x2')] ) 
       ( [0] ) )  ) 
- Integrating out: x2'/5
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(-1 * x2) > 0]
       ( [0] ) 
       ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
          ( [(1 * x2)] ) 
          ( [0] ) )  )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
- Ignoring current state or action variable x2 during elimination
- Ignoring current state or action variable k during elimination
- Ignoring current state or action variable x1 during elimination
- Added in reward post-marginalization with no interm/next state vars.
- Q^2(move1, [] )
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(-1 * x2) > 0]
       ( [(1 * x1)] ) 
       ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
          ( [((1 * x1) + (1 * x2))] ) 
          ( [(1 * x1)] ) )  )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
- Q^2(move1 ):
 No noise parameters to max over, skipping this step.
- Q^2(move1 ):
 No action parameters to max over, skipping this step.
Running max in iter 2:( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x1)] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x2)] ) )  )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 

>>> REGRESSING 'noop'

- Primed value function:
( [(1 + (-0.01 * k') + (-0.01 * x2')) > 0]
    ( [((1 * x1') + (-1 * x2')) > 0]
       ( [(1 + (-0.01 * k') + (-0.01 * x1')) > 0]
          ( [(1 * x1')] ) 
          ( [(1 * x2')] ) )  
       ( [(1 * x2')] ) )  
    ( [(1 + (-0.01 * k') + (-0.01 * x1')) > 0]
       ( [(1 * x1')] ) 
       ( [0] ) )  ) 
- Elimination order for regression: [k', x1', x2', x2, k, x1]
- Integrating out: k'/3
-->: ( [((1 * x1') + (-1 * x2')) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x1')) > 0]
       ( [(1 * x1')] ) 
       ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
          ( [(1 * x2')] ) 
          ( [0] ) )  )  
    ( [(1 + (-0.01 * k) + (-0.01 * x1')) > 0]
       ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
          ( [(1 * x2')] ) 
          ( [(1 * x1')] ) )  
       ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
          ( [(1 * x2')] ) 
          ( [0] ) )  )  ) 
- Integrating out: x1'/4
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
       ( [((1 * x1) + (-1 * x2')) > 0]
          ( [(1 * x1)] ) 
          ( [(1 * x2')] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2')) > 0]
       ( [(1 * x2')] ) 
       ( [0] ) )  ) 
- Integrating out: x2'/5
-->: ( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 * x1)] ) 
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
- Ignoring current state or action variable x2 during elimination
- Ignoring current state or action variable k during elimination
- Ignoring current state or action variable x1 during elimination
- Added in reward post-marginalization with no interm/next state vars.
- Q^2(noop, [] )
( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 * x1)] ) 
          ( [(1 * x2)] ) )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
- Q^2(noop ):
 No noise parameters to max over, skipping this step.
- Q^2(noop ):
 No action parameters to max over, skipping this step.
Running max in iter 2:( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x1)] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x2)] ) )  )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
Iter complete:2( [(1 + (-0.01 * k) + (-0.01 * x1)) > 0]
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [((1 * x1) + (-1 * x2)) > 0]
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x1)] ) )  
          ( [(1 + (-0.01 * k) + (-0.01 * x1) + (-0.01 * x2)) > 0]
             ( [((1 * x1) + (1 * x2))] ) 
             ( [(1 * x2)] ) )  )  
       ( [(1 * x1)] ) )  
    ( [(1 + (-0.01 * k) + (-0.01 * x2)) > 0]
       ( [(1 * x2)] ) 
       ( [0] ) )  ) 
Value function size @ end of iteration 2: 10 nodes = 7 cases in 107 ms

Value iteration complete!
2 iterations took 237 ms
Canonical / non-canonical: 747 / 256

Iteration Results summary
Iter 1: nodes = 7	branches = 5	time = 91 ms
Iter 2: nodes = 10	branches = 7	time = 107 ms
